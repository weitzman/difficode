name: Recipe Processing

on:
  schedule:
    # Run at 5am ET (9am UTC during standard time, 10am UTC during daylight time)
    # Using 9am UTC as the primary schedule
    - cron: '0 9 * * *'
#  push:
#    branches: [ main ]
  # Run on pull requests for validation
  pull_request:
    branches: [ main ]
  # Allow manual triggering for testing
  workflow_dispatch:

jobs:
  process-recipes:
    name: Process Recipe Changes
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      checks: write
    
    steps:
    - name: Checkout branch
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch full history
#        ref: ${{ github.head_ref }}

    - name: Fetch base branch
      run: git fetch origin ${{ github.event.pull_request.base.ref }}:${{ github.event.pull_request.base.ref }}

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Install Playwright browsers
      run: npx playwright install chromium
      
    - name: Get changed recipe files
      id: changed_files
      run: |
        # Get changed recipe files between current branch and target branch
        if [ "${{ github.event_name }}" = "pull_request" ]; then
          # For pull requests: compare with the target branch (main)
          CHANGED_FILES=$(git diff --name-only origin/${{ github.event.pull_request.base.ref }}...HEAD -- recipes/ | grep '\.json$' || true)
        else
          # For push events: compare with previous commit
          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD -- recipes/ | grep '\.json$' || true)
        fi
        
        if [ -z "$CHANGED_FILES" ]; then
          echo "No recipe files changed"
          echo "has_changes=false" >> $GITHUB_OUTPUT
          echo "changed_files=" >> $GITHUB_OUTPUT
        else
          echo "Changed recipe files:"
          echo "$CHANGED_FILES"
          # Convert newlines to spaces for command line usage
          CHANGED_FILES_ARGS=$(echo "$CHANGED_FILES" | tr '\n' ' ' | sed 's/[[:space:]]*$//')
          echo "has_changes=true" >> $GITHUB_OUTPUT
          echo "changed_files=$CHANGED_FILES_ARGS" >> $GITHUB_OUTPUT
        fi
        
    - name: Process recipes
      if: steps.changed_files.outputs.has_changes == 'true' || github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
      run: |
        if [ "${{ github.event_name }}" = "schedule" ] || [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          # For scheduled and manual runs, process all recipes
          node fetch-recipes.js --clean
        else
          # For PR/push runs, process specific changed recipes
          node fetch-recipes.js --clean --recipes ${{ steps.changed_files.outputs.changed_files }}
        fi
      
    - name: Generate job summary from report if available
      if: steps.changed_files.outputs.has_changes == 'true' || github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
      run: |
        if [ -f "report.md" ]; then
          echo "## Recipe Processing Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          cat report.md >> $GITHUB_STEP_SUMMARY
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            exit 1
          fi
        fi

#    - name: Check for git changes
#      id: changes
#      run: |
#        git config --local user.email "action@github.com"
#        git config --local user.name "GitHub Action"
#
#        # Check if there are any changes to commit
#        if git diff --quiet && git diff --staged --quiet; then
#          echo "No changes to commit"
#          echo "has_changes=false" >> $GITHUB_OUTPUT
#        else
#          echo "Changes detected"
#          echo "has_changes=true" >> $GITHUB_OUTPUT
#        fi
#
    - name: Update README agreements table
      run: |
        # Generate new table from recipes and save to temp file
        node list-recipes.js > new_table.tmp
        
        # Update README.md between the markers using sed
        sed '/<!-- START_AGREEMENTS -->/,/<!-- END_AGREEMENTS -->/{
          /<!-- START_AGREEMENTS -->/r new_table.tmp
          /<!-- END_AGREEMENTS -->/!d
        }' README.md > README.md.tmp && mv README.md.tmp README.md
        
        # Clean up temp file
        rm new_table.tmp
        
    - name: Prepare context files for Claude.
      id: commit-agreement-change
      run: |
        # Get list of all changed/new/deleted files in agreements directory
        CHANGED_AGREEMENTS=$(git diff --name-only agreements/ 2>/dev/null || true)
        STAGED_AGREEMENTS=$(git diff --staged --name-only agreements/ 2>/dev/null || true)

        # Combine and deduplicate
        ALL_CHANGED=$(echo -e "$CHANGED_AGREEMENTS\n$STAGED_AGREEMENTS" | sort | uniq | grep -v '^$' || true)

        if [ -n "$ALL_CHANGED" ]; then
          echo "Found changed files in agreements directory:"
          echo "$ALL_CHANGED"

          # Create a temporary script to process files with Claude
          cat > /tmp/process_agreements.sh << 'SCRIPT_EOF'
#!/bin/bash
echo "$1" | while IFS= read -r file; do
  if [ -n "$file" ]; then
    echo "Processing: $file"
    
    # Extract provider and document type from path
    PROVIDER=$(echo "$file" | cut -d'/' -f2)
    FILENAME=$(basename "$file" .md)
    
    # Check if file exists (not deleted)
    if [ -f "$file" ]; then
      # Stage the file first to get the diff
      git add "$file"
      
      # Get the git diff for this specific file
      DIFF_OUTPUT=$(git diff HEAD~1 "$file" 2>/dev/null || git diff --cached "$file" 2>/dev/null || echo "New file")
      
      # Get the current file content (first 5000 lines to avoid token limits)
      if [ -f "$file" ]; then
        FILE_CONTENT=$(head -5000 "$file")
      else
        FILE_CONTENT="File not found or is new"
      fi
      
      # Create context file for Claude
      cat > "/tmp/claude_context_$PROVIDER_$FILENAME.txt" << EOF
File: $file
Provider: $PROVIDER
Document Type: $FILENAME

=== CURRENT FILE CONTENT (first 5000 lines) ===
$FILE_CONTENT

=== GIT DIFF ===
$DIFF_OUTPUT
EOF
      
      echo "/tmp/claude_context_$PROVIDER_$FILENAME.txt"
      
    else
      # Handle deleted files
      git add "$file" 2>/dev/null || git rm "$file" 2>/dev/null || true
      git commit -m "ðŸ—‘ï¸ Remove $PROVIDER $FILENAME agreement"
      echo "DELETED:$file"
    fi
  fi
done
SCRIPT_EOF
          
          chmod +x /tmp/process_agreements.sh
          
          # Get context files to process
          CONTEXT_FILES=$(/tmp/process_agreements.sh "$ALL_CHANGED")
          
          # Store files for commit processing
          echo "$CONTEXT_FILES" > /tmp/files_to_commit.txt
        else
          echo "No files changed in agreements directory"
          echo "" > /tmp/files_to_commit.txt
        fi
        
    - name: Generate commit messages with Claude
      id: claude_messages
      if: hashFiles('/tmp/files_to_commit.txt') != ''
      uses: anthropics/claude-code-action@beta
      with:
        claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
        instructions_file: .github/prompts/commit-message-generator.md
        
    - name: Process commits with output from Claude
      run: |
        if [ -f "/tmp/files_to_commit.txt" ] && [ -s "/tmp/files_to_commit.txt" ]; then
          # Get Claude's response
          CLAUDE_OUTPUT="${{ steps.claude_messages.outputs.response }}"
          
          # Process each context file
          while IFS= read -r context_file; do
            if [ -n "$context_file" ] && [[ "$context_file" == "/tmp/claude_context_"* ]]; then
              # Extract provider and filename from context file name
              BASENAME=$(basename "$context_file" .txt)
              PROVIDER=$(echo "$BASENAME" | cut -d'_' -f3)
              FILENAME=$(echo "$BASENAME" | cut -d'_' -f4-)
              
              # Look for Claude's message for this file
              COMMIT_MSG=""
              if [ -n "$CLAUDE_OUTPUT" ]; then
                COMMIT_MSG=$(echo "$CLAUDE_OUTPUT" | grep "^$BASENAME:" | cut -d':' -f2- | head -1)
              fi
              
              # Use fallback if no Claude message
              if [ -z "$COMMIT_MSG" ]; then
                COMMIT_MSG="ðŸ“„ Update $PROVIDER $FILENAME agreement"
              fi
              
              # The file should already be staged from the previous step
              # Just commit with the message
              git commit -m "$COMMIT_MSG"
              echo "âœ… Committed: $COMMIT_MSG"
              
              # Clean up context file
              rm -f "$context_file"
            fi
          done < /tmp/files_to_commit.txt
          
          # Clean up temp files
          rm -f /tmp/files_to_commit.txt /tmp/process_agreements.sh
        else
          echo "No agreement files to commit"
        fi
        
    - name: Commit README updates
      run: |
        # Check if README.md has changes
        if git diff --quiet README.md && git diff --staged --quiet README.md; then
          echo "No changes to README.md"
        else
          echo "README.md has changes, committing..."
          git add README.md
          git commit -m "ðŸ“‹ Update agreements table in README.md"
        fi
        
    - name: Push all changes
      run: |
        # Push all commits at once
        git push origin ${{ github.head_ref }}
        
#    - name: Set check status
#      if: always()
#      uses: actions/github-script@v7
#      with:
#        script: |
#          const { owner, repo } = context.repo;
#          const { sha } = context.payload.pull_request?.head || context;
#
#          // Determine status based on job outcome
#          const conclusion = '${{ job.status }}' === 'success' ? 'success' : 'failure';
#          const title = conclusion === 'success' ?
#            'âœ… Recipe processing completed successfully' :
#            'âŒ Recipe processing failed';
#
#          // Create a check run for this commit
#          await github.rest.checks.create({
#            owner,
#            repo,
#            name: 'Recipe Processing',
#            head_sha: sha,
#            status: 'completed',
#            conclusion: conclusion,
#            output: {
#              title: title,
#              summary: conclusion === 'success' ?
#                'All recipe changes processed successfully with no errors.' :
#                'Recipe processing encountered errors. Check the workflow logs and job summary for details.'
#            }
#          });
          
    - name: Final status check
      if: always()
      run: |
        if [ "${{ job.status }}" = "failure" ]; then
          echo "::error::Recipe processing workflow failed"
          echo "âŒ Recipe processing check failed"
          exit 1
        else
          echo "::notice::Recipe processing workflow completed successfully" 
          echo "âœ… Recipe processing check completed successfully"
        fi